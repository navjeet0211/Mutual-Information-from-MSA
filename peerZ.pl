#!/usr/bin/perl -w
###
#Calculate MIp or MIa
###

use strict;
use Statistics::Lite qw(:all);

(my $help = <<HELP_DOC) =~ s/\t+//gm;
	
	This generates Z scores with whole alignment neighbors. Requires the 
	Statistics::Lite Perl module be installed
	
	Output is to the last columns of the file by command redirection.
	
	#note you may have to change the column where MI resides if the
	results are non-sensical. Works fine for files generated by 
	MI.pl
		
	product is MIcd -((avg MIcx * avg MIxd) / avg MIxx)
	sum is MIcd - avg MIcx - avg MIxd + avg MIxx
	
	Arguments for this program are:
	-i input file name
	-o output file base name
	     base name will have _MIp.txt appended
	-e minimum entropy value for the calculations (default 0.0001)
	     This is to stratify the data set. In general it is best
	     to leave this at the default.
	-s sum or product (default product)
	-a return all positions (default F)
	      returns only those above the entropy cutoff
	-h print this help
	     
HELP_DOC

my $MI_column = 5;	#column where  MI information resides in MI.pl output
my $H_column_1 = 2;	#columns where entropy information is stored
my $H_column_2 = 3;
my $H_pair_column = 4;	
my $min_entropy = 0.0001;	#minimum entropy cutoff

my $file_name;		#input file name
my @goodH;			#array to hold data with H> Hmin
my @lowH; 			#array to hold data with H <= Hmin
my @sorted_data;		#array to hold the sorted and calculate data with H > Hmin
my @all;			#array to hold all data
my @sum; 			#array to hold Hc + Hd values
my %HoA;
my %MImean;
my $SorP = "product"; 	#use the product or sum correction to give MIp or MIa
my $all = "F";		#return all pairs even if not used in the calculation of MIp or MIa
my @idx; 			#an index array to perform sorting of one array by the values in another
my $output; 	#this will hold the entire output
my $out_file = "junk";

#get the arguements for the calculations
if (@ARGV){
	my $i = 0;
	foreach my $item(@ARGV){
	$i++;
		if ($item eq "-i"){	#input file name
			$file_name = $ARGV[$i];
		}elsif ($item eq "-e"){	#minimum entropy
			$min_entropy = $ARGV[$i];
		}elsif ($item eq "-s"){ #sum or product
			$SorP = $ARGV[$i];
		}elsif ($item eq "-o"){ #sum or product
			$out_file = $ARGV[$i];
		}elsif($item eq "-h"){	#print the help information
			print $help;
			exit;
		}
	}
}else{
	print $help;
	exit;
}

#open the file output by MI.pl and place a number of values in arrays for use later on
open (IN, "< $file_name") || die "Too bad $! $file_name\n";
	while(defined(my $l = <IN>)){
		chomp $l;
		my @l = split/\t/, $l;
		#the line must be a data line and both positions must be above the minimum entropy cutoff
		if($l[0] =~ m/\d/ && $l[$H_column_1] >= $min_entropy && $l[$H_column_2] >= $min_entropy){
			$l[$MI_column] = $l[$MI_column]; # / $l[$H_pair_column];
			push @goodH, $l;					#populate an array of the data as input
			push @{ $HoA{$l[0]} }, $l[$MI_column];	#populate an array of positions and MI values
			push @{ $HoA{$l[1]} }, $l[$MI_column];	#populate for both position c and d
			push @all, $l[$MI_column];			#populate an array of all MI values
			
		
		#the lowH data are captured, by default they are not used or printed out
		}elsif ($l[0] =~ m/\d/){ #keep all the low H pairs and just zero out the row
			$l .= "\t0\t0\t0\t0\t0\t0\n";
			push @lowH, $l;
		}
	}
close IN;

#capture the mean MI of all pairs in the alignment using the Statistics::Lite module
#@all is emptied after this step as we don't need the original data and can reuse the 
#array for something else
my $global_mean = mean @all;
@all = (); #reinitialize @all and use it for the data from goodH

#make a sorted list of positions because this makes it easier to troubleshoot
my @positions = sort {$a <=> $b}(keys %HoA);

#get the mean MI value for each position. Note that MI does not provide the 
#MI of a position with itself
foreach my $pos(@positions){
	#my @middle = @{ $HoA{$pos} }; #[19 .. (scalar @{ $HoA{$pos} }) - 19];
	#my $mean = mean @middle;
	my $mean =mean @{ $HoA{$pos} };
	$MImean{$pos} = $mean;
}

#Here is where the MIp or MIa calculation is actually done with the 
#data stored in the above variables. These can be MIp for the product correction
#or MIa for the sum correction, in either case, we only use the values if both 
#positions have an entropy above the cutoff. This was ensured when the file was 
#opened and values were read into the variables
#we are stepping through data lines from MI.pl, where the entropy is over the threshold
foreach my $l(@goodH){
	my @l = split/\t/, $l;
	my $mip;
	if($SorP eq "product"){
		$mip = ($l[$MI_column] ) - (($MImean{$l[0]} * $MImean{$l[1]} ) / $global_mean);
	}elsif($SorP eq "sum"){
		$mip = ($l[$MI_column] ) -  $MImean{$l[0]} - $MImean{$l[1]} + $global_mean;
	}
	#make an index array of the APCp or APCa value
	push @idx,$mip;
	#append the $mip value to the data line from MI.pl
	$mip = sprintf("%0.5f", $mip);
	$l .= "\t$mip";
	push @all, $l;
}

#I like the data sorted from highest MIp score to the lowest
@sorted_data = @all[ sort { $idx[$b]<=>$idx[$a] } 0 .. $#idx ]; 
#this calculates the mean and standard deviation of MIp for use in outputting
#Z scores
my $average = sprintf("%0.5f", mean @idx);
my $stdev = sprintf("%0.5f", stddev @idx);

	
my $Z = 0;
my $Z4 = $average + $stdev * 4;

#we are stepping through data lines from MI.pl with MIp appended, where the entropy is over the threshold
#calculate the Z score and append it to the line
#for reasons of compatability there are a number of superfluous columns
#the column after MIp is just MI, I hoped to add other info here but did not
#the columns containing the average MIp, stdev of MIp and Z4 are also fairly 
#worthless, but some downstream programs rely on the correct column count so 
#I'm stuck with them for now.
for (my $i = 0; $i< scalar @sorted_data; $i++){
	my @line = split/\t/,$sorted_data[$i];
	$Z = sprintf("%0.5f", ($line[-1] - $average)/$stdev );
	$sorted_data[$i] .= "\t$line[$MI_column]\t$average\t$stdev\t$Z\t$Z4\n";
	$output .= "$sorted_data[$i]";
	if ($all eq "T"){
		foreach (@lowH){
			$output .= "$_\n";	
		}
	}
}
my $header = "c\td\tHc\tHd\tHcd\tMIcd\taa_c\taa_d\tMIp\tMIcd\tmean_MI\tstdev\tZ\t4Z\n";
$out_file .= "_MIp.txt";
open (OUT, "> $out_file") || die "Too bad $! $file_name\n";
	print OUT $header;
	print OUT $output;
close OUT;
